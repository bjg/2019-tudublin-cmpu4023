// Code generated by Prisma (prisma@1.28.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  categories: (where?: CategoriesWhereInput) => Promise<boolean>;
  cust_hist: (where?: Cust_histWhereInput) => Promise<boolean>;
  customers: (where?: CustomersWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  orderlines: (where?: OrderlinesWhereInput) => Promise<boolean>;
  orders: (where?: OrdersWhereInput) => Promise<boolean>;
  products: (where?: ProductsWhereInput) => Promise<boolean>;
  reorder: (where?: ReorderWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  categories: (where: CategoriesWhereUniqueInput) => CategoriesPromise;
  categorieses: (
    args?: {
      where?: CategoriesWhereInput;
      orderBy?: CategoriesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Categories>;
  categoriesesConnection: (
    args?: {
      where?: CategoriesWhereInput;
      orderBy?: CategoriesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoriesConnectionPromise;
  cust_hist: (where: Cust_histWhereUniqueInput) => Cust_histPromise;
  cust_hists: (
    args?: {
      where?: Cust_histWhereInput;
      orderBy?: Cust_histOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cust_hist>;
  cust_histsConnection: (
    args?: {
      where?: Cust_histWhereInput;
      orderBy?: Cust_histOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Cust_histConnectionPromise;
  customers: (where: CustomersWhereUniqueInput) => CustomersPromise;
  customerses: (
    args?: {
      where?: CustomersWhereInput;
      orderBy?: CustomersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Customers>;
  customersesConnection: (
    args?: {
      where?: CustomersWhereInput;
      orderBy?: CustomersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CustomersConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  inventories: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Inventory>;
  inventoriesConnection: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InventoryConnectionPromise;
  orderlines: (where: OrderlinesWhereUniqueInput) => OrderlinesPromise;
  orderlineses: (
    args?: {
      where?: OrderlinesWhereInput;
      orderBy?: OrderlinesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Orderlines>;
  orderlinesesConnection: (
    args?: {
      where?: OrderlinesWhereInput;
      orderBy?: OrderlinesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrderlinesConnectionPromise;
  orders: (where: OrdersWhereUniqueInput) => OrdersPromise;
  orderses: (
    args?: {
      where?: OrdersWhereInput;
      orderBy?: OrdersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Orders>;
  ordersesConnection: (
    args?: {
      where?: OrdersWhereInput;
      orderBy?: OrdersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrdersConnectionPromise;
  products: (where: ProductsWhereUniqueInput) => ProductsPromise;
  productses: (
    args?: {
      where?: ProductsWhereInput;
      orderBy?: ProductsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Products>;
  productsesConnection: (
    args?: {
      where?: ProductsWhereInput;
      orderBy?: ProductsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductsConnectionPromise;
  reorder: (where: ReorderWhereUniqueInput) => ReorderPromise;
  reorders: (
    args?: {
      where?: ReorderWhereInput;
      orderBy?: ReorderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Reorder>;
  reordersConnection: (
    args?: {
      where?: ReorderWhereInput;
      orderBy?: ReorderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReorderConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategories: (data: CategoriesCreateInput) => CategoriesPromise;
  updateCategories: (
    args: { data: CategoriesUpdateInput; where: CategoriesWhereUniqueInput }
  ) => CategoriesPromise;
  updateManyCategorieses: (
    args: {
      data: CategoriesUpdateManyMutationInput;
      where?: CategoriesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCategories: (
    args: {
      where: CategoriesWhereUniqueInput;
      create: CategoriesCreateInput;
      update: CategoriesUpdateInput;
    }
  ) => CategoriesPromise;
  deleteCategories: (where: CategoriesWhereUniqueInput) => CategoriesPromise;
  deleteManyCategorieses: (where?: CategoriesWhereInput) => BatchPayloadPromise;
  createCust_hist: (data: Cust_histCreateInput) => Cust_histPromise;
  updateCust_hist: (
    args: { data: Cust_histUpdateInput; where: Cust_histWhereUniqueInput }
  ) => Cust_histPromise;
  upsertCust_hist: (
    args: {
      where: Cust_histWhereUniqueInput;
      create: Cust_histCreateInput;
      update: Cust_histUpdateInput;
    }
  ) => Cust_histPromise;
  deleteCust_hist: (where: Cust_histWhereUniqueInput) => Cust_histPromise;
  deleteManyCust_hists: (where?: Cust_histWhereInput) => BatchPayloadPromise;
  createCustomers: (data: CustomersCreateInput) => CustomersPromise;
  updateCustomers: (
    args: { data: CustomersUpdateInput; where: CustomersWhereUniqueInput }
  ) => CustomersPromise;
  updateManyCustomerses: (
    args: {
      data: CustomersUpdateManyMutationInput;
      where?: CustomersWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCustomers: (
    args: {
      where: CustomersWhereUniqueInput;
      create: CustomersCreateInput;
      update: CustomersUpdateInput;
    }
  ) => CustomersPromise;
  deleteCustomers: (where: CustomersWhereUniqueInput) => CustomersPromise;
  deleteManyCustomerses: (where?: CustomersWhereInput) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (
    args: { data: InventoryUpdateInput; where: InventoryWhereUniqueInput }
  ) => InventoryPromise;
  updateManyInventories: (
    args: {
      data: InventoryUpdateManyMutationInput;
      where?: InventoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertInventory: (
    args: {
      where: InventoryWhereUniqueInput;
      create: InventoryCreateInput;
      update: InventoryUpdateInput;
    }
  ) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createOrderlines: (data: OrderlinesCreateInput) => OrderlinesPromise;
  updateOrderlines: (
    args: { data: OrderlinesUpdateInput; where: OrderlinesWhereUniqueInput }
  ) => OrderlinesPromise;
  updateManyOrderlineses: (
    args: {
      data: OrderlinesUpdateManyMutationInput;
      where?: OrderlinesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOrderlines: (
    args: {
      where: OrderlinesWhereUniqueInput;
      create: OrderlinesCreateInput;
      update: OrderlinesUpdateInput;
    }
  ) => OrderlinesPromise;
  deleteOrderlines: (where: OrderlinesWhereUniqueInput) => OrderlinesPromise;
  deleteManyOrderlineses: (where?: OrderlinesWhereInput) => BatchPayloadPromise;
  createOrders: (data: OrdersCreateInput) => OrdersPromise;
  updateOrders: (
    args: { data: OrdersUpdateInput; where: OrdersWhereUniqueInput }
  ) => OrdersPromise;
  updateManyOrderses: (
    args: { data: OrdersUpdateManyMutationInput; where?: OrdersWhereInput }
  ) => BatchPayloadPromise;
  upsertOrders: (
    args: {
      where: OrdersWhereUniqueInput;
      create: OrdersCreateInput;
      update: OrdersUpdateInput;
    }
  ) => OrdersPromise;
  deleteOrders: (where: OrdersWhereUniqueInput) => OrdersPromise;
  deleteManyOrderses: (where?: OrdersWhereInput) => BatchPayloadPromise;
  createProducts: (data: ProductsCreateInput) => ProductsPromise;
  updateProducts: (
    args: { data: ProductsUpdateInput; where: ProductsWhereUniqueInput }
  ) => ProductsPromise;
  updateManyProductses: (
    args: { data: ProductsUpdateManyMutationInput; where?: ProductsWhereInput }
  ) => BatchPayloadPromise;
  upsertProducts: (
    args: {
      where: ProductsWhereUniqueInput;
      create: ProductsCreateInput;
      update: ProductsUpdateInput;
    }
  ) => ProductsPromise;
  deleteProducts: (where: ProductsWhereUniqueInput) => ProductsPromise;
  deleteManyProductses: (where?: ProductsWhereInput) => BatchPayloadPromise;
  createReorder: (data: ReorderCreateInput) => ReorderPromise;
  updateReorder: (
    args: { data: ReorderUpdateInput; where: ReorderWhereUniqueInput }
  ) => ReorderPromise;
  updateManyReorders: (
    args: { data: ReorderUpdateManyMutationInput; where?: ReorderWhereInput }
  ) => BatchPayloadPromise;
  upsertReorder: (
    args: {
      where: ReorderWhereUniqueInput;
      create: ReorderCreateInput;
      update: ReorderUpdateInput;
    }
  ) => ReorderPromise;
  deleteReorder: (where: ReorderWhereUniqueInput) => ReorderPromise;
  deleteManyReorders: (where?: ReorderWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  categories: (
    where?: CategoriesSubscriptionWhereInput
  ) => CategoriesSubscriptionPayloadSubscription;
  cust_hist: (
    where?: Cust_histSubscriptionWhereInput
  ) => Cust_histSubscriptionPayloadSubscription;
  customers: (
    where?: CustomersSubscriptionWhereInput
  ) => CustomersSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  orderlines: (
    where?: OrderlinesSubscriptionWhereInput
  ) => OrderlinesSubscriptionPayloadSubscription;
  orders: (
    where?: OrdersSubscriptionWhereInput
  ) => OrdersSubscriptionPayloadSubscription;
  products: (
    where?: ProductsSubscriptionWhereInput
  ) => ProductsSubscriptionPayloadSubscription;
  reorder: (
    where?: ReorderSubscriptionWhereInput
  ) => ReorderSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Cust_histOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "country_ASC"
  | "country_DESC"
  | "region_ASC"
  | "region_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "creditcardtype_ASC"
  | "creditcardtype_DESC"
  | "creditcard_ASC"
  | "creditcard_DESC"
  | "creditcardexpiration_ASC"
  | "creditcardexpiration_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "age_ASC"
  | "age_DESC"
  | "income_ASC"
  | "income_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quan_in_stock_ASC"
  | "quan_in_stock_DESC"
  | "sales_ASC"
  | "sales_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderlinesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "orderdate_ASC"
  | "orderdate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrdersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "orderdate_ASC"
  | "orderdate_DESC"
  | "netamount_ASC"
  | "netamount_DESC"
  | "tax_ASC"
  | "tax_DESC"
  | "totalamount_ASC"
  | "totalamount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "categoryname_ASC"
  | "categoryname_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "actor_ASC"
  | "actor_DESC"
  | "price_ASC"
  | "price_DESC"
  | "special_ASC"
  | "special_DESC"
  | "common_prod_id_ASC"
  | "common_prod_id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReorderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_low_ASC"
  | "date_low_DESC"
  | "quan_low_ASC"
  | "quan_low_DESC"
  | "date_reordered_ASC"
  | "date_reordered_DESC"
  | "quan_reordered_ASC"
  | "quan_reordered_DESC"
  | "date_expected_ASC"
  | "date_expected_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CustomersCreateOneInput {
  create?: CustomersCreateInput;
  connect?: CustomersWhereUniqueInput;
}

export type CategoriesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InventoryCreateInput {
  quan_in_stock?: Int;
  sales?: Int;
  products?: ProductsCreateOneWithoutInventoryInput;
}

export interface OrdersUpdateOneInput {
  create?: OrdersCreateInput;
  update?: OrdersUpdateDataInput;
  upsert?: OrdersUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: OrdersWhereUniqueInput;
}

export interface CustomersUpdateManyMutationInput {
  firstname?: String;
  lastname?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  country?: String;
  region?: String;
  email?: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username?: String;
  password?: String;
  age?: Int;
  income?: Float;
  gender?: String;
}

export interface ProductsCreateInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
  categories?: CategoriesCreateOneInput;
  inventory?: InventoryCreateOneWithoutProductsInput;
}

export interface CustomersUpdateInput {
  firstname?: String;
  lastname?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  country?: String;
  region?: String;
  email?: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username?: String;
  password?: String;
  age?: Int;
  income?: Float;
  gender?: String;
}

export interface ProductsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductsWhereInput;
  AND?: ProductsSubscriptionWhereInput[] | ProductsSubscriptionWhereInput;
  OR?: ProductsSubscriptionWhereInput[] | ProductsSubscriptionWhereInput;
  NOT?: ProductsSubscriptionWhereInput[] | ProductsSubscriptionWhereInput;
}

export type ProductsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrderlinesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderlinesWhereInput;
  AND?: OrderlinesSubscriptionWhereInput[] | OrderlinesSubscriptionWhereInput;
  OR?: OrderlinesSubscriptionWhereInput[] | OrderlinesSubscriptionWhereInput;
  NOT?: OrderlinesSubscriptionWhereInput[] | OrderlinesSubscriptionWhereInput;
}

export interface CategoriesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  categoryname?: String;
  categoryname_not?: String;
  categoryname_in?: String[] | String;
  categoryname_not_in?: String[] | String;
  categoryname_lt?: String;
  categoryname_lte?: String;
  categoryname_gt?: String;
  categoryname_gte?: String;
  categoryname_contains?: String;
  categoryname_not_contains?: String;
  categoryname_starts_with?: String;
  categoryname_not_starts_with?: String;
  categoryname_ends_with?: String;
  categoryname_not_ends_with?: String;
  AND?: CategoriesWhereInput[] | CategoriesWhereInput;
  OR?: CategoriesWhereInput[] | CategoriesWhereInput;
  NOT?: CategoriesWhereInput[] | CategoriesWhereInput;
}

export interface CustomersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomersWhereInput;
  AND?: CustomersSubscriptionWhereInput[] | CustomersSubscriptionWhereInput;
  OR?: CustomersSubscriptionWhereInput[] | CustomersSubscriptionWhereInput;
  NOT?: CustomersSubscriptionWhereInput[] | CustomersSubscriptionWhereInput;
}

export interface ProductsUpsertNestedInput {
  update: ProductsUpdateDataInput;
  create: ProductsCreateInput;
}

export interface Cust_histWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  customers?: CustomersWhereInput;
  orders?: OrdersWhereInput;
  products?: ProductsWhereInput;
  AND?: Cust_histWhereInput[] | Cust_histWhereInput;
  OR?: Cust_histWhereInput[] | Cust_histWhereInput;
  NOT?: Cust_histWhereInput[] | Cust_histWhereInput;
}

export interface InventoryUpsertWithoutProductsInput {
  update: InventoryUpdateWithoutProductsDataInput;
  create: InventoryCreateWithoutProductsInput;
}

export interface OrdersWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orderdate?: DateTimeInput;
  orderdate_not?: DateTimeInput;
  orderdate_in?: DateTimeInput[] | DateTimeInput;
  orderdate_not_in?: DateTimeInput[] | DateTimeInput;
  orderdate_lt?: DateTimeInput;
  orderdate_lte?: DateTimeInput;
  orderdate_gt?: DateTimeInput;
  orderdate_gte?: DateTimeInput;
  netamount?: Float;
  netamount_not?: Float;
  netamount_in?: Float[] | Float;
  netamount_not_in?: Float[] | Float;
  netamount_lt?: Float;
  netamount_lte?: Float;
  netamount_gt?: Float;
  netamount_gte?: Float;
  tax?: Float;
  tax_not?: Float;
  tax_in?: Float[] | Float;
  tax_not_in?: Float[] | Float;
  tax_lt?: Float;
  tax_lte?: Float;
  tax_gt?: Float;
  tax_gte?: Float;
  totalamount?: Float;
  totalamount_not?: Float;
  totalamount_in?: Float[] | Float;
  totalamount_not_in?: Float[] | Float;
  totalamount_lt?: Float;
  totalamount_lte?: Float;
  totalamount_gt?: Float;
  totalamount_gte?: Float;
  customers?: CustomersWhereInput;
  AND?: OrdersWhereInput[] | OrdersWhereInput;
  OR?: OrdersWhereInput[] | OrdersWhereInput;
  NOT?: OrdersWhereInput[] | OrdersWhereInput;
}

export interface InventoryUpdateWithoutProductsDataInput {
  quan_in_stock?: Int;
  sales?: Int;
}

export interface InventoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  quan_in_stock?: Int;
  quan_in_stock_not?: Int;
  quan_in_stock_in?: Int[] | Int;
  quan_in_stock_not_in?: Int[] | Int;
  quan_in_stock_lt?: Int;
  quan_in_stock_lte?: Int;
  quan_in_stock_gt?: Int;
  quan_in_stock_gte?: Int;
  sales?: Int;
  sales_not?: Int;
  sales_in?: Int[] | Int;
  sales_not_in?: Int[] | Int;
  sales_lt?: Int;
  sales_lte?: Int;
  sales_gt?: Int;
  sales_gte?: Int;
  products?: ProductsWhereInput;
  AND?: InventoryWhereInput[] | InventoryWhereInput;
  OR?: InventoryWhereInput[] | InventoryWhereInput;
  NOT?: InventoryWhereInput[] | InventoryWhereInput;
}

export type ReorderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReorderUpdateManyMutationInput {
  date_low?: DateTimeInput;
  quan_low?: Int;
  date_reordered?: DateTimeInput;
  quan_reordered?: Int;
  date_expected?: String;
}

export interface InventoryUpdateOneWithoutProductsInput {
  create?: InventoryCreateWithoutProductsInput;
  update?: InventoryUpdateWithoutProductsDataInput;
  upsert?: InventoryUpsertWithoutProductsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InventoryWhereUniqueInput;
}

export interface ReorderCreateInput {
  date_low: DateTimeInput;
  quan_low?: Int;
  date_reordered: DateTimeInput;
  quan_reordered?: Int;
  date_expected?: String;
  products?: ProductsCreateOneInput;
}

export interface ReorderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date_low?: DateTimeInput;
  date_low_not?: DateTimeInput;
  date_low_in?: DateTimeInput[] | DateTimeInput;
  date_low_not_in?: DateTimeInput[] | DateTimeInput;
  date_low_lt?: DateTimeInput;
  date_low_lte?: DateTimeInput;
  date_low_gt?: DateTimeInput;
  date_low_gte?: DateTimeInput;
  quan_low?: Int;
  quan_low_not?: Int;
  quan_low_in?: Int[] | Int;
  quan_low_not_in?: Int[] | Int;
  quan_low_lt?: Int;
  quan_low_lte?: Int;
  quan_low_gt?: Int;
  quan_low_gte?: Int;
  date_reordered?: DateTimeInput;
  date_reordered_not?: DateTimeInput;
  date_reordered_in?: DateTimeInput[] | DateTimeInput;
  date_reordered_not_in?: DateTimeInput[] | DateTimeInput;
  date_reordered_lt?: DateTimeInput;
  date_reordered_lte?: DateTimeInput;
  date_reordered_gt?: DateTimeInput;
  date_reordered_gte?: DateTimeInput;
  quan_reordered?: Int;
  quan_reordered_not?: Int;
  quan_reordered_in?: Int[] | Int;
  quan_reordered_not_in?: Int[] | Int;
  quan_reordered_lt?: Int;
  quan_reordered_lte?: Int;
  quan_reordered_gt?: Int;
  quan_reordered_gte?: Int;
  date_expected?: String;
  date_expected_not?: String;
  date_expected_in?: String[] | String;
  date_expected_not_in?: String[] | String;
  date_expected_lt?: String;
  date_expected_lte?: String;
  date_expected_gt?: String;
  date_expected_gte?: String;
  date_expected_contains?: String;
  date_expected_not_contains?: String;
  date_expected_starts_with?: String;
  date_expected_not_starts_with?: String;
  date_expected_ends_with?: String;
  date_expected_not_ends_with?: String;
  products?: ProductsWhereInput;
  AND?: ReorderWhereInput[] | ReorderWhereInput;
  OR?: ReorderWhereInput[] | ReorderWhereInput;
  NOT?: ReorderWhereInput[] | ReorderWhereInput;
}

export interface ProductsUpdateManyMutationInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
}

export interface CategoriesUpsertNestedInput {
  update: CategoriesUpdateDataInput;
  create: CategoriesCreateInput;
}

export interface OrdersUpdateManyMutationInput {
  orderdate?: DateTimeInput;
  netamount?: Float;
  tax?: Float;
  totalamount?: Float;
}

export interface CategoriesUpdateDataInput {
  categoryname?: String;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoriesUpdateOneInput {
  create?: CategoriesCreateInput;
  update?: CategoriesUpdateDataInput;
  upsert?: CategoriesUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CategoriesWhereUniqueInput;
}

export interface OrderlinesUpdateInput {
  quantity?: Int;
  orderdate?: DateTimeInput;
  orders?: OrdersUpdateOneInput;
  products?: ProductsUpdateOneInput;
}

export interface ProductsUpdateDataInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
  categories?: CategoriesUpdateOneInput;
  inventory?: InventoryUpdateOneWithoutProductsInput;
}

export interface InventoryUpdateManyMutationInput {
  quan_in_stock?: Int;
  sales?: Int;
}

export interface ProductsUpsertWithoutInventoryInput {
  update: ProductsUpdateWithoutInventoryDataInput;
  create: ProductsCreateWithoutInventoryInput;
}

export interface ProductsUpdateWithoutInventoryDataInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
  categories?: CategoriesUpdateOneInput;
}

export interface CategoriesCreateInput {
  categoryname: String;
}

export interface InventoryUpdateInput {
  quan_in_stock?: Int;
  sales?: Int;
  products?: ProductsUpdateOneWithoutInventoryInput;
}

export interface CategoriesUpdateInput {
  categoryname?: String;
}

export type OrdersWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoriesUpdateManyMutationInput {
  categoryname?: String;
}

export interface ReorderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReorderWhereInput;
  AND?: ReorderSubscriptionWhereInput[] | ReorderSubscriptionWhereInput;
  OR?: ReorderSubscriptionWhereInput[] | ReorderSubscriptionWhereInput;
  NOT?: ReorderSubscriptionWhereInput[] | ReorderSubscriptionWhereInput;
}

export interface ProductsUpdateOneInput {
  create?: ProductsCreateInput;
  update?: ProductsUpdateDataInput;
  upsert?: ProductsUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductsWhereUniqueInput;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InventoryWhereInput;
  AND?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  OR?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  NOT?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
}

export interface OrdersUpsertNestedInput {
  update: OrdersUpdateDataInput;
  create: OrdersCreateInput;
}

export interface CustomersWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  address1?: String;
  address1_not?: String;
  address1_in?: String[] | String;
  address1_not_in?: String[] | String;
  address1_lt?: String;
  address1_lte?: String;
  address1_gt?: String;
  address1_gte?: String;
  address1_contains?: String;
  address1_not_contains?: String;
  address1_starts_with?: String;
  address1_not_starts_with?: String;
  address1_ends_with?: String;
  address1_not_ends_with?: String;
  address2?: String;
  address2_not?: String;
  address2_in?: String[] | String;
  address2_not_in?: String[] | String;
  address2_lt?: String;
  address2_lte?: String;
  address2_gt?: String;
  address2_gte?: String;
  address2_contains?: String;
  address2_not_contains?: String;
  address2_starts_with?: String;
  address2_not_starts_with?: String;
  address2_ends_with?: String;
  address2_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  creditcardtype?: String;
  creditcardtype_not?: String;
  creditcardtype_in?: String[] | String;
  creditcardtype_not_in?: String[] | String;
  creditcardtype_lt?: String;
  creditcardtype_lte?: String;
  creditcardtype_gt?: String;
  creditcardtype_gte?: String;
  creditcardtype_contains?: String;
  creditcardtype_not_contains?: String;
  creditcardtype_starts_with?: String;
  creditcardtype_not_starts_with?: String;
  creditcardtype_ends_with?: String;
  creditcardtype_not_ends_with?: String;
  creditcard?: String;
  creditcard_not?: String;
  creditcard_in?: String[] | String;
  creditcard_not_in?: String[] | String;
  creditcard_lt?: String;
  creditcard_lte?: String;
  creditcard_gt?: String;
  creditcard_gte?: String;
  creditcard_contains?: String;
  creditcard_not_contains?: String;
  creditcard_starts_with?: String;
  creditcard_not_starts_with?: String;
  creditcard_ends_with?: String;
  creditcard_not_ends_with?: String;
  creditcardexpiration?: String;
  creditcardexpiration_not?: String;
  creditcardexpiration_in?: String[] | String;
  creditcardexpiration_not_in?: String[] | String;
  creditcardexpiration_lt?: String;
  creditcardexpiration_lte?: String;
  creditcardexpiration_gt?: String;
  creditcardexpiration_gte?: String;
  creditcardexpiration_contains?: String;
  creditcardexpiration_not_contains?: String;
  creditcardexpiration_starts_with?: String;
  creditcardexpiration_not_starts_with?: String;
  creditcardexpiration_ends_with?: String;
  creditcardexpiration_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  age?: Int;
  age_not?: Int;
  age_in?: Int[] | Int;
  age_not_in?: Int[] | Int;
  age_lt?: Int;
  age_lte?: Int;
  age_gt?: Int;
  age_gte?: Int;
  income?: Float;
  income_not?: Float;
  income_in?: Float[] | Float;
  income_not_in?: Float[] | Float;
  income_lt?: Float;
  income_lte?: Float;
  income_gt?: Float;
  income_gte?: Float;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  AND?: CustomersWhereInput[] | CustomersWhereInput;
  OR?: CustomersWhereInput[] | CustomersWhereInput;
  NOT?: CustomersWhereInput[] | CustomersWhereInput;
}

export interface Cust_histCreateInput {
  customers?: CustomersCreateOneInput;
  orders?: OrdersCreateOneInput;
  products?: ProductsCreateOneInput;
}

export interface CategoriesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoriesWhereInput;
  AND?: CategoriesSubscriptionWhereInput[] | CategoriesSubscriptionWhereInput;
  OR?: CategoriesSubscriptionWhereInput[] | CategoriesSubscriptionWhereInput;
  NOT?: CategoriesSubscriptionWhereInput[] | CategoriesSubscriptionWhereInput;
}

export interface OrdersUpdateDataInput {
  orderdate?: DateTimeInput;
  netamount?: Float;
  tax?: Float;
  totalamount?: Float;
  customers?: CustomersUpdateOneInput;
}

export type CustomersWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
}>;

export interface CustomersCreateInput {
  firstname: String;
  lastname: String;
  address1: String;
  address2?: String;
  city: String;
  state: String;
  zip?: String;
  country: String;
  region?: String;
  email: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username: String;
  password: String;
  age: Int;
  income?: Float;
  gender: String;
}

export interface OrdersUpdateInput {
  orderdate?: DateTimeInput;
  netamount?: Float;
  tax?: Float;
  totalamount?: Float;
  customers?: CustomersUpdateOneInput;
}

export interface OrdersCreateOneInput {
  create?: OrdersCreateInput;
  connect?: OrdersWhereUniqueInput;
}

export interface OrderlinesCreateInput {
  quantity?: Int;
  orderdate: DateTimeInput;
  orders?: OrdersCreateOneInput;
  products?: ProductsCreateOneInput;
}

export interface OrdersCreateInput {
  orderdate: DateTimeInput;
  netamount: Float;
  tax: Float;
  totalamount: Float;
  customers?: CustomersCreateOneInput;
}

export interface OrderlinesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  orderdate?: DateTimeInput;
  orderdate_not?: DateTimeInput;
  orderdate_in?: DateTimeInput[] | DateTimeInput;
  orderdate_not_in?: DateTimeInput[] | DateTimeInput;
  orderdate_lt?: DateTimeInput;
  orderdate_lte?: DateTimeInput;
  orderdate_gt?: DateTimeInput;
  orderdate_gte?: DateTimeInput;
  orders?: OrdersWhereInput;
  products?: ProductsWhereInput;
  AND?: OrderlinesWhereInput[] | OrderlinesWhereInput;
  OR?: OrderlinesWhereInput[] | OrderlinesWhereInput;
  NOT?: OrderlinesWhereInput[] | OrderlinesWhereInput;
}

export interface ProductsCreateOneInput {
  create?: ProductsCreateInput;
  connect?: ProductsWhereUniqueInput;
}

export interface ProductsCreateWithoutInventoryInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
  categories?: CategoriesCreateOneInput;
}

export type Cust_histWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrdersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrdersWhereInput;
  AND?: OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput;
  OR?: OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput;
  NOT?: OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput;
}

export interface CategoriesCreateOneInput {
  create?: CategoriesCreateInput;
  connect?: CategoriesWhereUniqueInput;
}

export interface ProductsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  actor?: String;
  actor_not?: String;
  actor_in?: String[] | String;
  actor_not_in?: String[] | String;
  actor_lt?: String;
  actor_lte?: String;
  actor_gt?: String;
  actor_gte?: String;
  actor_contains?: String;
  actor_not_contains?: String;
  actor_starts_with?: String;
  actor_not_starts_with?: String;
  actor_ends_with?: String;
  actor_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  special?: Boolean;
  special_not?: Boolean;
  common_prod_id?: Int;
  common_prod_id_not?: Int;
  common_prod_id_in?: Int[] | Int;
  common_prod_id_not_in?: Int[] | Int;
  common_prod_id_lt?: Int;
  common_prod_id_lte?: Int;
  common_prod_id_gt?: Int;
  common_prod_id_gte?: Int;
  categories?: CategoriesWhereInput;
  inventory?: InventoryWhereInput;
  AND?: ProductsWhereInput[] | ProductsWhereInput;
  OR?: ProductsWhereInput[] | ProductsWhereInput;
  NOT?: ProductsWhereInput[] | ProductsWhereInput;
}

export interface InventoryCreateOneWithoutProductsInput {
  create?: InventoryCreateWithoutProductsInput;
  connect?: InventoryWhereUniqueInput;
}

export interface ProductsUpdateInput {
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
  categories?: CategoriesUpdateOneInput;
  inventory?: InventoryUpdateOneWithoutProductsInput;
}

export interface InventoryCreateWithoutProductsInput {
  quan_in_stock?: Int;
  sales?: Int;
}

export type OrderlinesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CustomersUpsertNestedInput {
  update: CustomersUpdateDataInput;
  create: CustomersCreateInput;
}

export interface CustomersUpdateDataInput {
  firstname?: String;
  lastname?: String;
  address1?: String;
  address2?: String;
  city?: String;
  state?: String;
  zip?: String;
  country?: String;
  region?: String;
  email?: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username?: String;
  password?: String;
  age?: Int;
  income?: Float;
  gender?: String;
}

export interface CustomersUpdateOneInput {
  create?: CustomersCreateInput;
  update?: CustomersUpdateDataInput;
  upsert?: CustomersUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CustomersWhereUniqueInput;
}

export interface Cust_histUpdateInput {
  customers?: CustomersUpdateOneInput;
  orders?: OrdersUpdateOneInput;
  products?: ProductsUpdateOneInput;
}

export interface ProductsUpdateOneWithoutInventoryInput {
  create?: ProductsCreateWithoutInventoryInput;
  update?: ProductsUpdateWithoutInventoryDataInput;
  upsert?: ProductsUpsertWithoutInventoryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductsWhereUniqueInput;
}

export interface OrderlinesUpdateManyMutationInput {
  quantity?: Int;
  orderdate?: DateTimeInput;
}

export interface ReorderUpdateInput {
  date_low?: DateTimeInput;
  quan_low?: Int;
  date_reordered?: DateTimeInput;
  quan_reordered?: Int;
  date_expected?: String;
  products?: ProductsUpdateOneInput;
}

export interface Cust_histSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: Cust_histWhereInput;
  AND?: Cust_histSubscriptionWhereInput[] | Cust_histSubscriptionWhereInput;
  OR?: Cust_histSubscriptionWhereInput[] | Cust_histSubscriptionWhereInput;
  NOT?: Cust_histSubscriptionWhereInput[] | Cust_histSubscriptionWhereInput;
}

export interface ProductsCreateOneWithoutInventoryInput {
  create?: ProductsCreateWithoutInventoryInput;
  connect?: ProductsWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ReorderPreviousValues {
  id: ID_Output;
  date_low: DateTimeOutput;
  quan_low?: Int;
  date_reordered: DateTimeOutput;
  quan_reordered?: Int;
  date_expected?: String;
}

export interface ReorderPreviousValuesPromise
  extends Promise<ReorderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date_low: () => Promise<DateTimeOutput>;
  quan_low: () => Promise<Int>;
  date_reordered: () => Promise<DateTimeOutput>;
  quan_reordered: () => Promise<Int>;
  date_expected: () => Promise<String>;
}

export interface ReorderPreviousValuesSubscription
  extends Promise<AsyncIterator<ReorderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date_low: () => Promise<AsyncIterator<DateTimeOutput>>;
  quan_low: () => Promise<AsyncIterator<Int>>;
  date_reordered: () => Promise<AsyncIterator<DateTimeOutput>>;
  quan_reordered: () => Promise<AsyncIterator<Int>>;
  date_expected: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCust_hist {
  count: Int;
}

export interface AggregateCust_histPromise
  extends Promise<AggregateCust_hist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCust_histSubscription
  extends Promise<AsyncIterator<AggregateCust_hist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCategories {
  count: Int;
}

export interface AggregateCategoriesPromise
  extends Promise<AggregateCategories>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategoriesSubscription
  extends Promise<AsyncIterator<AggregateCategories>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Cust_histEdge {
  node: Cust_hist;
  cursor: String;
}

export interface Cust_histEdgePromise
  extends Promise<Cust_histEdge>,
    Fragmentable {
  node: <T = Cust_histPromise>() => T;
  cursor: () => Promise<String>;
}

export interface Cust_histEdgeSubscription
  extends Promise<AsyncIterator<Cust_histEdge>>,
    Fragmentable {
  node: <T = Cust_histSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Cust_histConnection {
  pageInfo: PageInfo;
  edges: Cust_histEdge[];
}

export interface Cust_histConnectionPromise
  extends Promise<Cust_histConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<Cust_histEdge>>() => T;
  aggregate: <T = AggregateCust_histPromise>() => T;
}

export interface Cust_histConnectionSubscription
  extends Promise<AsyncIterator<Cust_histConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Cust_histEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCust_histSubscription>() => T;
}

export interface ReorderEdge {
  node: Reorder;
  cursor: String;
}

export interface ReorderEdgePromise extends Promise<ReorderEdge>, Fragmentable {
  node: <T = ReorderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReorderEdgeSubscription
  extends Promise<AsyncIterator<ReorderEdge>>,
    Fragmentable {
  node: <T = ReorderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductsPreviousValues {
  id: ID_Output;
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
}

export interface ProductsPreviousValuesPromise
  extends Promise<ProductsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  actor: () => Promise<String>;
  price: () => Promise<Float>;
  special: () => Promise<Boolean>;
  common_prod_id: () => Promise<Int>;
}

export interface ProductsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  actor: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  special: () => Promise<AsyncIterator<Boolean>>;
  common_prod_id: () => Promise<AsyncIterator<Int>>;
}

export interface OrdersPreviousValues {
  id: ID_Output;
  orderdate: DateTimeOutput;
  netamount: Float;
  tax: Float;
  totalamount: Float;
}

export interface OrdersPreviousValuesPromise
  extends Promise<OrdersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  orderdate: () => Promise<DateTimeOutput>;
  netamount: () => Promise<Float>;
  tax: () => Promise<Float>;
  totalamount: () => Promise<Float>;
}

export interface OrdersPreviousValuesSubscription
  extends Promise<AsyncIterator<OrdersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  netamount: () => Promise<AsyncIterator<Float>>;
  tax: () => Promise<AsyncIterator<Float>>;
  totalamount: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateReorder {
  count: Int;
}

export interface AggregateReorderPromise
  extends Promise<AggregateReorder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReorderSubscription
  extends Promise<AsyncIterator<AggregateReorder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoriesEdge {
  node: Categories;
  cursor: String;
}

export interface CategoriesEdgePromise
  extends Promise<CategoriesEdge>,
    Fragmentable {
  node: <T = CategoriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoriesEdgeSubscription
  extends Promise<AsyncIterator<CategoriesEdge>>,
    Fragmentable {
  node: <T = CategoriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReorderConnection {
  pageInfo: PageInfo;
  edges: ReorderEdge[];
}

export interface ReorderConnectionPromise
  extends Promise<ReorderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReorderEdge>>() => T;
  aggregate: <T = AggregateReorderPromise>() => T;
}

export interface ReorderConnectionSubscription
  extends Promise<AsyncIterator<ReorderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReorderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReorderSubscription>() => T;
}

export interface ProductsEdge {
  node: Products;
  cursor: String;
}

export interface ProductsEdgePromise
  extends Promise<ProductsEdge>,
    Fragmentable {
  node: <T = ProductsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductsEdgeSubscription
  extends Promise<AsyncIterator<ProductsEdge>>,
    Fragmentable {
  node: <T = ProductsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Reorder {
  id: ID_Output;
  date_low: DateTimeOutput;
  quan_low?: Int;
  date_reordered: DateTimeOutput;
  quan_reordered?: Int;
  date_expected?: String;
}

export interface ReorderPromise extends Promise<Reorder>, Fragmentable {
  id: () => Promise<ID_Output>;
  date_low: () => Promise<DateTimeOutput>;
  quan_low: () => Promise<Int>;
  date_reordered: () => Promise<DateTimeOutput>;
  quan_reordered: () => Promise<Int>;
  date_expected: () => Promise<String>;
  products: <T = ProductsPromise>() => T;
}

export interface ReorderSubscription
  extends Promise<AsyncIterator<Reorder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date_low: () => Promise<AsyncIterator<DateTimeOutput>>;
  quan_low: () => Promise<AsyncIterator<Int>>;
  date_reordered: () => Promise<AsyncIterator<DateTimeOutput>>;
  quan_reordered: () => Promise<AsyncIterator<Int>>;
  date_expected: () => Promise<AsyncIterator<String>>;
  products: <T = ProductsSubscription>() => T;
}

export interface AggregateOrders {
  count: Int;
}

export interface AggregateOrdersPromise
  extends Promise<AggregateOrders>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrdersSubscription
  extends Promise<AsyncIterator<AggregateOrders>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Categories {
  id: ID_Output;
  categoryname: String;
}

export interface CategoriesPromise extends Promise<Categories>, Fragmentable {
  id: () => Promise<ID_Output>;
  categoryname: () => Promise<String>;
}

export interface CategoriesSubscription
  extends Promise<AsyncIterator<Categories>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  categoryname: () => Promise<AsyncIterator<String>>;
}

export interface OrdersConnection {
  pageInfo: PageInfo;
  edges: OrdersEdge[];
}

export interface OrdersConnectionPromise
  extends Promise<OrdersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrdersEdge>>() => T;
  aggregate: <T = AggregateOrdersPromise>() => T;
}

export interface OrdersConnectionSubscription
  extends Promise<AsyncIterator<OrdersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrdersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrdersSubscription>() => T;
}

export interface CategoriesSubscriptionPayload {
  mutation: MutationType;
  node: Categories;
  updatedFields: String[];
  previousValues: CategoriesPreviousValues;
}

export interface CategoriesSubscriptionPayloadPromise
  extends Promise<CategoriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoriesPreviousValuesPromise>() => T;
}

export interface CategoriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategoriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategoriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoriesPreviousValuesSubscription>() => T;
}

export interface AggregateOrderlines {
  count: Int;
}

export interface AggregateOrderlinesPromise
  extends Promise<AggregateOrderlines>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderlinesSubscription
  extends Promise<AsyncIterator<AggregateOrderlines>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoriesPreviousValues {
  id: ID_Output;
  categoryname: String;
}

export interface CategoriesPreviousValuesPromise
  extends Promise<CategoriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  categoryname: () => Promise<String>;
}

export interface CategoriesPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  categoryname: () => Promise<AsyncIterator<String>>;
}

export interface OrderlinesConnection {
  pageInfo: PageInfo;
  edges: OrderlinesEdge[];
}

export interface OrderlinesConnectionPromise
  extends Promise<OrderlinesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderlinesEdge>>() => T;
  aggregate: <T = AggregateOrderlinesPromise>() => T;
}

export interface OrderlinesConnectionSubscription
  extends Promise<AsyncIterator<OrderlinesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderlinesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderlinesSubscription>() => T;
}

export interface Inventory {
  id: ID_Output;
  quan_in_stock?: Int;
  sales?: Int;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  quan_in_stock: () => Promise<Int>;
  sales: () => Promise<Int>;
  products: <T = ProductsPromise>() => T;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quan_in_stock: () => Promise<AsyncIterator<Int>>;
  sales: () => Promise<AsyncIterator<Int>>;
  products: <T = ProductsSubscription>() => T;
}

export interface Orderlines {
  id: ID_Output;
  quantity?: Int;
  orderdate: DateTimeOutput;
}

export interface OrderlinesPromise extends Promise<Orderlines>, Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  orderdate: () => Promise<DateTimeOutput>;
  orders: <T = OrdersPromise>() => T;
  products: <T = ProductsPromise>() => T;
}

export interface OrderlinesSubscription
  extends Promise<AsyncIterator<Orderlines>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  orderdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  orders: <T = OrdersSubscription>() => T;
  products: <T = ProductsSubscription>() => T;
}

export interface Cust_histSubscriptionPayload {
  mutation: MutationType;
  node: Cust_hist;
  updatedFields: String[];
  previousValues: Cust_histPreviousValues;
}

export interface Cust_histSubscriptionPayloadPromise
  extends Promise<Cust_histSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Cust_histPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Cust_histPreviousValuesPromise>() => T;
}

export interface Cust_histSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Cust_histSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Cust_histSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Cust_histPreviousValuesSubscription>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Cust_histPreviousValues {
  id: ID_Output;
}

export interface Cust_histPreviousValuesPromise
  extends Promise<Cust_histPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface Cust_histPreviousValuesSubscription
  extends Promise<AsyncIterator<Cust_histPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Products {
  id: ID_Output;
  title?: String;
  actor?: String;
  price?: Float;
  special?: Boolean;
  common_prod_id?: Int;
}

export interface ProductsPromise extends Promise<Products>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  actor: () => Promise<String>;
  price: () => Promise<Float>;
  special: () => Promise<Boolean>;
  common_prod_id: () => Promise<Int>;
  categories: <T = CategoriesPromise>() => T;
  inventory: <T = InventoryPromise>() => T;
}

export interface ProductsSubscription
  extends Promise<AsyncIterator<Products>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  actor: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  special: () => Promise<AsyncIterator<Boolean>>;
  common_prod_id: () => Promise<AsyncIterator<Int>>;
  categories: <T = CategoriesSubscription>() => T;
  inventory: <T = InventorySubscription>() => T;
}

export interface CustomersEdge {
  node: Customers;
  cursor: String;
}

export interface CustomersEdgePromise
  extends Promise<CustomersEdge>,
    Fragmentable {
  node: <T = CustomersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomersEdgeSubscription
  extends Promise<AsyncIterator<CustomersEdge>>,
    Fragmentable {
  node: <T = CustomersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomersSubscriptionPayload {
  mutation: MutationType;
  node: Customers;
  updatedFields: String[];
  previousValues: CustomersPreviousValues;
}

export interface CustomersSubscriptionPayloadPromise
  extends Promise<CustomersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomersPreviousValuesPromise>() => T;
}

export interface CustomersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomersPreviousValuesSubscription>() => T;
}

export interface Cust_hist {
  id: ID_Output;
}

export interface Cust_histPromise extends Promise<Cust_hist>, Fragmentable {
  id: () => Promise<ID_Output>;
  customers: <T = CustomersPromise>() => T;
  orders: <T = OrdersPromise>() => T;
  products: <T = ProductsPromise>() => T;
}

export interface Cust_histSubscription
  extends Promise<AsyncIterator<Cust_hist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customers: <T = CustomersSubscription>() => T;
  orders: <T = OrdersSubscription>() => T;
  products: <T = ProductsSubscription>() => T;
}

export interface CustomersPreviousValues {
  id: ID_Output;
  firstname: String;
  lastname: String;
  address1: String;
  address2?: String;
  city: String;
  state: String;
  zip?: String;
  country: String;
  region?: String;
  email: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username: String;
  password: String;
  age: Int;
  income?: Float;
  gender: String;
}

export interface CustomersPreviousValuesPromise
  extends Promise<CustomersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  creditcardtype: () => Promise<String>;
  creditcard: () => Promise<String>;
  creditcardexpiration: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  age: () => Promise<Int>;
  income: () => Promise<Float>;
  gender: () => Promise<String>;
}

export interface CustomersPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  creditcardtype: () => Promise<AsyncIterator<String>>;
  creditcard: () => Promise<AsyncIterator<String>>;
  creditcardexpiration: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  income: () => Promise<AsyncIterator<Float>>;
  gender: () => Promise<AsyncIterator<String>>;
}

export interface ProductsConnection {
  pageInfo: PageInfo;
  edges: ProductsEdge[];
}

export interface ProductsConnectionPromise
  extends Promise<ProductsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductsEdge>>() => T;
  aggregate: <T = AggregateProductsPromise>() => T;
}

export interface ProductsConnectionSubscription
  extends Promise<AsyncIterator<ProductsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductsSubscription>() => T;
}

export interface ProductsSubscriptionPayload {
  mutation: MutationType;
  node: Products;
  updatedFields: String[];
  previousValues: ProductsPreviousValues;
}

export interface ProductsSubscriptionPayloadPromise
  extends Promise<ProductsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductsPreviousValuesPromise>() => T;
}

export interface ProductsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductsPreviousValuesSubscription>() => T;
}

export interface ReorderSubscriptionPayload {
  mutation: MutationType;
  node: Reorder;
  updatedFields: String[];
  previousValues: ReorderPreviousValues;
}

export interface ReorderSubscriptionPayloadPromise
  extends Promise<ReorderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReorderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReorderPreviousValuesPromise>() => T;
}

export interface ReorderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReorderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReorderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReorderPreviousValuesSubscription>() => T;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface CategoriesConnection {
  pageInfo: PageInfo;
  edges: CategoriesEdge[];
}

export interface CategoriesConnectionPromise
  extends Promise<CategoriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoriesEdge>>() => T;
  aggregate: <T = AggregateCategoriesPromise>() => T;
}

export interface CategoriesConnectionSubscription
  extends Promise<AsyncIterator<CategoriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoriesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategoriesSubscription>() => T;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  quan_in_stock?: Int;
  sales?: Int;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quan_in_stock: () => Promise<Int>;
  sales: () => Promise<Int>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quan_in_stock: () => Promise<AsyncIterator<Int>>;
  sales: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface Orders {
  id: ID_Output;
  orderdate: DateTimeOutput;
  netamount: Float;
  tax: Float;
  totalamount: Float;
}

export interface OrdersPromise extends Promise<Orders>, Fragmentable {
  id: () => Promise<ID_Output>;
  orderdate: () => Promise<DateTimeOutput>;
  netamount: () => Promise<Float>;
  tax: () => Promise<Float>;
  totalamount: () => Promise<Float>;
  customers: <T = CustomersPromise>() => T;
}

export interface OrdersSubscription
  extends Promise<AsyncIterator<Orders>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  netamount: () => Promise<AsyncIterator<Float>>;
  tax: () => Promise<AsyncIterator<Float>>;
  totalamount: () => Promise<AsyncIterator<Float>>;
  customers: <T = CustomersSubscription>() => T;
}

export interface CustomersConnection {
  pageInfo: PageInfo;
  edges: CustomersEdge[];
}

export interface CustomersConnectionPromise
  extends Promise<CustomersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomersEdge>>() => T;
  aggregate: <T = AggregateCustomersPromise>() => T;
}

export interface CustomersConnectionSubscription
  extends Promise<AsyncIterator<CustomersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomersSubscription>() => T;
}

export interface OrdersEdge {
  node: Orders;
  cursor: String;
}

export interface OrdersEdgePromise extends Promise<OrdersEdge>, Fragmentable {
  node: <T = OrdersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrdersEdgeSubscription
  extends Promise<AsyncIterator<OrdersEdge>>,
    Fragmentable {
  node: <T = OrdersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrdersSubscriptionPayload {
  mutation: MutationType;
  node: Orders;
  updatedFields: String[];
  previousValues: OrdersPreviousValues;
}

export interface OrdersSubscriptionPayloadPromise
  extends Promise<OrdersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrdersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrdersPreviousValuesPromise>() => T;
}

export interface OrdersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrdersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrdersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrdersPreviousValuesSubscription>() => T;
}

export interface Customers {
  id: ID_Output;
  firstname: String;
  lastname: String;
  address1: String;
  address2?: String;
  city: String;
  state: String;
  zip?: String;
  country: String;
  region?: String;
  email: String;
  phone?: String;
  creditcardtype?: String;
  creditcard?: String;
  creditcardexpiration?: String;
  username: String;
  password: String;
  age: Int;
  income?: Float;
  gender: String;
}

export interface CustomersPromise extends Promise<Customers>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  creditcardtype: () => Promise<String>;
  creditcard: () => Promise<String>;
  creditcardexpiration: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  age: () => Promise<Int>;
  income: () => Promise<Float>;
  gender: () => Promise<String>;
}

export interface CustomersSubscription
  extends Promise<AsyncIterator<Customers>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  creditcardtype: () => Promise<AsyncIterator<String>>;
  creditcard: () => Promise<AsyncIterator<String>>;
  creditcardexpiration: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  income: () => Promise<AsyncIterator<Float>>;
  gender: () => Promise<AsyncIterator<String>>;
}

export interface OrderlinesPreviousValues {
  id: ID_Output;
  quantity?: Int;
  orderdate: DateTimeOutput;
}

export interface OrderlinesPreviousValuesPromise
  extends Promise<OrderlinesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  orderdate: () => Promise<DateTimeOutput>;
}

export interface OrderlinesPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderlinesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  orderdate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderlinesSubscriptionPayload {
  mutation: MutationType;
  node: Orderlines;
  updatedFields: String[];
  previousValues: OrderlinesPreviousValues;
}

export interface OrderlinesSubscriptionPayloadPromise
  extends Promise<OrderlinesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderlinesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderlinesPreviousValuesPromise>() => T;
}

export interface OrderlinesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderlinesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderlinesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderlinesPreviousValuesSubscription>() => T;
}

export interface OrderlinesEdge {
  node: Orderlines;
  cursor: String;
}

export interface OrderlinesEdgePromise
  extends Promise<OrderlinesEdge>,
    Fragmentable {
  node: <T = OrderlinesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderlinesEdgeSubscription
  extends Promise<AsyncIterator<OrderlinesEdge>>,
    Fragmentable {
  node: <T = OrderlinesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProducts {
  count: Int;
}

export interface AggregateProductsPromise
  extends Promise<AggregateProducts>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductsSubscription
  extends Promise<AsyncIterator<AggregateProducts>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCustomers {
  count: Int;
}

export interface AggregateCustomersPromise
  extends Promise<AggregateCustomers>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomersSubscription
  extends Promise<AsyncIterator<AggregateCustomers>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Customers",
    embedded: false
  },
  {
    name: "Orders",
    embedded: false
  },
  {
    name: "Categories",
    embedded: false
  },
  {
    name: "Products",
    embedded: false
  },
  {
    name: "Reorder",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "Orderlines",
    embedded: false
  },
  {
    name: "Cust_hist",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
